### HTTP 状态码

HTTP 状态码是服务器向客户端返回的三位数数字代码，用于表示请求的处理结果。理解这些状态码有助于快速定位网络请求问题，下面将从分类、常见状态码及实际应用场景展开说明。

#### **一、状态码分类：五大类核心类别**

根据状态码的首位数字，可分为以下 5 类：

- **1xx（信息类）**：服务器已接收请求，正在处理中。
- **2xx（成功类）**：请求已成功接收、理解并处理。
- **3xx（重定向类）**：需要客户端进一步操作以完成请求。
- **4xx（客户端错误类）**：客户端请求存在错误。
- **5xx（服务器错误类）**：服务器处理请求时发生错误。

#### **二、常见 HTTP 状态码详解**

以下是开发中最常遇到的状态码，包含示例场景和解决方案：

##### **1. 1xx 信息类状态码（较少见）**

- 100 Continue
  - **含义**：客户端请求的头部已接收，等待发送主体内容。
  - **场景**：当请求体较大时，客户端先发送头部询问服务器是否接收，服务器返回 100 后再发送主体（如上传大文件）。

##### **2. 2xx 成功类状态码（最常用）**

- **200 OK**

  - **含义**：请求成功，返回预期结果。

  - **场景**：正常获取 API 数据（如 `GET /users` 返回用户列表）。

  - 示例响应：

    ```json
    {
      "code": 200,
      "data": ["user1", "user2"],
      "message": "请求成功"
    }
    ```

- **201 Created**

  - **含义**：请求已成功，且服务器创建了新资源。

  - **场景**：调用 `POST /users` 创建新用户时返回。

  - 示例响应头：

    ```http
    HTTP/1.1 201 Created
    Location: https://api.example.com/users/123  // 新资源的地址
    ```

- **204 No Content**

  - **含义**：请求成功，但无需返回内容（常用于删除操作）。
  - **场景**：调用 `DELETE /posts/1` 删除文章后，返回空响应。

##### **3. 3xx 重定向类状态码（需客户端进一步操作）**

- **301 Moved Permanently**
  - **含义**：资源永久迁移，客户端应使用新 URL 访问。
  - **场景**：网站域名变更（如 `example.com` 永久跳转到 `new-example.com`）。
  - **注意**：浏览器会缓存新 URL，避免重复请求。
- **302 Found（或 303 See Other）**
  - **含义**：资源临时迁移，客户端应使用新 URL 重新请求。
  - **场景**：登录成功后跳转到首页（`POST /login` 后重定向到 `GET /home`）。
  - **区别**：303 明确要求使用 `GET` 方法重新请求。
- **304 Not Modified**
  - **含义**：资源未修改，客户端可使用缓存内容。
  - **场景**：浏览器请求资源时，服务器通过 `Last-Modified` 或 `ETag` 判断资源未更新，返回 304 减少带宽消耗。

##### **4. 4xx 客户端错误类状态码（前端常见问题）**

- **400 Bad Request**
  - **含义**：客户端请求格式错误（如参数缺失、JSON 格式错误）。
  - **场景**：调用 `POST /api/form` 时缺少必填字段 `name`。
  - **解决方案**：检查请求参数是否符合 API 文档要求。
- **401 Unauthorized**
  - **含义**：未授权，需提供身份验证信息。
  - **场景**：访问需要登录的接口（如 `GET /admin/data`）未携带 Token。
  - **解决方案**：前端跳转登录页或重新获取 Token。
- **403 Forbidden**
  - **含义**：服务器拒绝请求（权限不足）。
  - **场景**：普通用户尝试访问管理员接口（如 `GET /admin/users`）。
  - **区别**：401 是未认证，403 是已认证但无权限。
- **404 Not Found**
  - **含义**：请求的资源不存在。
  - **场景**：访问错误的 URL（如 `GET /api/posts/999` 对应文章已删除）。
  - **解决方案**：检查 URL 是否正确，或实现 404 页面引导用户。
- **429 Too Many Requests**
  - **含义**：请求频率过高，被服务器限制。
  - **场景**：短时间内多次提交表单或调用接口。
  - **解决方案**：前端添加请求防抖，或提示用户稍后再试。

##### **5. 5xx 服务器错误类状态码（后端问题）**

- **500 Internal Server Error**
  - **含义**：服务器内部错误（如代码异常、数据库连接失败）。
  - **场景**：后端代码执行时抛出未捕获的异常（如数组越界、SQL 错误）。
  - **解决方案**：后端查看日志定位错误，前端显示 “服务器异常，请稍后重试”。
- **502 Bad Gateway**
  - **含义**：服务器作为网关或代理时，从上游服务器收到无效响应。
  - **场景**：微服务架构中，某服务节点崩溃，网关转发请求失败。
  - **解决方案**：检查上游服务是否正常，添加服务熔断或重试机制。
- **503 Service Unavailable**
  - **含义**：服务器暂时无法处理请求（过载或维护中）。
  - **场景**：电商大促时服务器流量过高，或系统正在升级。
  - **解决方案**：前端显示维护页面，后端扩容或启用限流策略。
- **504 Gateway Timeout**
  - **含义**：网关或代理服务器等待上游响应超时。
  - **场景**：复杂查询接口执行时间过长（如数据库慢查询）。
  - **解决方案**：优化后端接口性能，增加超时重试机制。

#### **三、实战应用：状态码与前端处理策略**

在前端开发中，通常通过 `fetch` 或 `axios` 处理状态码：

```javascript
// 使用 axios 处理状态码示例
axios.get('/api/data')
  .then(response => {
    const status = response.status;
    if (status === 200) {
      // 处理正常数据
      console.log('数据获取成功', response.data);
    } else if (status === 304) {
      // 使用缓存数据
      console.log('使用缓存内容');
    }
  })
  .catch(error => {
    const status = error.response?.status;
    switch (status) {
      case 401:
        // 未认证，跳转登录
        localStorage.removeItem('token');
        window.location.href = '/login';
        break;
      case 404:
        // 页面不存在，跳转 404 页
        window.location.href = '/404';
        break;
      case 500:
        // 服务器错误，提示用户
        alert('服务器异常，请稍后重试');
        break;
      default:
        console.error('请求错误', error);
    }
  });
```

#### **四、扩展：自定义状态码与业务结合**

在实际项目中，后端常自定义业务状态码（如 `20000` 表示成功，`40001` 表示参数错误），需在响应中明确说明：

```json
{
  "code": 20000,       // 业务状态码
  "httpStatus": 200,   // HTTP 状态码
  "message": "操作成功",
  "data": { /* 数据 */ }
}
```

这种方式可更精准地描述业务逻辑，同时兼容 HTTP 标准状态码体系。

#### **总结**

HTTP 状态码是客户端与服务器通信的 “语言”，掌握它们的含义和处理方式能有效提升调试效率。开发中需注意：

- 前端根据状态码给出友好的用户提示；
- 后端合理使用状态码，避免过度依赖 `200 OK` 掩盖错误；
- 复杂场景下结合业务状态码与 HTTP 状态码，提升接口可读性。